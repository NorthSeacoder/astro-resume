# OA 拆分技术方案
一、背景
1.1 业务背景
- 现状业务痛点:
  - 系统能力与演进迟缓: 当前OA系统 oa-next (基于 React 16 + AntD 4) 是一个大型单体应用，承载了基础 OA 功能，并衍生出针对特定场景的多个系统变体：OMS (外包管理系统)、ECOMS (印尼外包管理系统) 和 KMG (面向 kmg 主体员工的 OA 办公系统)。这种模式导致：
    - 迭代效率低下: 代码耦合，逻辑上存在多份相似但有差异的实现（如不同的 API 服务、登录逻辑、页面参数展示、通讯方式差异等）。公共部分改动可能会影响多个应用的功能。
    - 维护成本高昂: 不同业务变体的差异化修改散落在代码各处，缺乏清晰管理，追踪困难，极易引入跨系统缺陷（例如，修改 OMS 功能可能无意中影响 KMG 运行）。
    - CI/CD 效率低下: 每次代码提交触发的 CI 构建需打包编译整个应用，平均耗时达到 8 分钟，严重影响了开发反馈速度和部署频率。
  - 用户体验不足:
    - UI 老旧: 系统界面停留在 AntD 4 时代，视觉风格陈旧。
1.2 现状分析
- 现行技术方案:
  - 一个基于 React 16.x 和 Ant Design v4.24 的大型单体前端应用 (oa-next)。
  - 有两版封装的组件,class 组件+函数式组件混杂,两版权限校验函数
  - 所有业务逻辑（基础 OA, OMS, ECOMS, KMG）的代码物理上混合在同一个代码库中。
  - 通过条件判断语句 (if/else)、环境变量读取、甚至部分复制代码的方式来处理 OMS/ECOMS/KMG 相对于基础 OA 的功能和配置差异。 KMG/OMS/ECOMS 管理方式不同
  - 使用单一的 Webpack (开发使用 Vite) 配置进行整体构建和打包。
  - CI/CD 流程针对整个单体应用执行。
- 痛点:
  - 高耦合: 单体架构使得不同业务模块（OA/OMS/KMG）的代码在物理和逻辑上紧密耦合，任何修改都可能牵一发而动全身，测试范围广，风险高，无法实现模块的独立演进和部署。
  - 组件混乱: 旧组件功能完善但 API 老旧,新组件 API 清晰但功能不足
  - 变体管理混乱: 缺乏结构化的方式管理衍生变体的差异，导致代码中充斥着难以维护的条件逻辑，增加了代码复杂度，降低了可读性，且容易在修改某一变体逻辑时误伤其他变体。
  - 构建效率低下: 整个应用必须作为一个单元进行编译和打包，导致 CI/CD 流程耗时过长。
  - 技术栈升级困难: 单体架构使得对部分模块（如 OMS）进行技术栈升级（如升级 React 18/AntD 5）变得极其困难和高风险，容易被旧代码和依赖拖累。
1.3 产品需求
  - 两个OA,一个是迁移中的 OA,新旧 UI 混杂的;另一个是旧 OA
  - 一个 OA,有新旧两个版本
二、目标
1. 第一阶段目标:
  - 架构基础: 成功搭建 pnpm + Turborepo Monorepo 环境。
  - OMS 独立: 将 OMS 相关业务代码 (含 ECOMS 变体逻辑) 从 oa-next 完全剥离至独立的 packages/oms 包。
  - 共享基础: 提取 oms 运行必需的共享代码至 packages/shared-core (与框架无关) 和 packages/shared-legacy-ui (React 16/AntD 4 兼容)。
  - 差异管理: 在 packages/oms 内部实现基于环境变量和配置文件的 OMS/ECOMS 变体差异管理机制 (服务地址, Chidori 版本, 参数, 通讯方式等)。
  - 达成标志: packages/oms 能够独立开发、构建、运行和部署 (使用 Vite + R16/A4)；CI 构建 oms 的时间显著缩短 (相比全量构建)。
2. 第二阶段目标 :
  - 新宿主创建: 创建新的 packages/oms-next 应用，采用现代框架 (Umi v4 或 yqg-max，待定) 和技术栈 (React 18 / AntD 5)。
  - 微前端集成: 选用合适的微前端方案 (Qiankun 或 yqg-max 内置方案 或 MF，待定)，配置 oms-next (主应用) 加载并运行 packages/oms (子应用)。
  - 达成标志: oms-next 可成功运行，并在其页面内完整嵌入并展示来自旧 oms 的页面/功能模块；集成方案稳定可行。
3. 第三阶段目标:
  - 新 UI 体系: 基于新设计稿，利用公司 slimFit 组件库（或封装一层形成 shared-modern-ui），建立适用于 React 18/AntD 5 的 UI 体系。
  - 渐进替换: 在 oms-next 应用中，开始使用新 UI 组件，按模块（例如 整体页面框架 -> 日常办公等模块）逐步重写和替换通过微前端嵌入的旧 oms 模块/页面。
  - 达成标志: oms-next 中至少一个核心模块使用新 UI 完成重写并替代旧模块；新重写模块能正确处理 OMS/ECOMS 变体配置；现代化迁移流程得到验证。
4. CI/CD 效率提升 (贯穿各阶段):
  - 工具利用: 充分利用 Turborepo 的构建缓存和任务调度能力。
  - 达成标志: 针对单个应用（如 oms 或 oms-next）及其依赖的 CI 构建时间，相比原单体全量构建时间（8 分钟），缩短 60% 以上。
5. 代码质量与可维护性提升 (贯穿各阶段):
  - 结构优化: 通过 Monorepo、分层共享包 (shared-core, shared-legacy-ui, shared-modern-ui/slimFit) 和清晰的模块划分，提升代码组织性。
  - 配置化: 通过规范的配置管理变体差异，提高代码可读性和可维护性。
  - 达成标志: 关键共享逻辑统一管理；代码库结构清晰；变体差异易于管理。
三、技术方案
3.1 技术调研
1. Monorepo 管理工具:
  - 对比维度: 依赖管理效率、磁盘空间占用、安装速度、工作区脚本执行能力、社区支持。
  - 方案: pnpm vs. Yarn Workspaces。
  - 结论: pnpm。
    - 优势: 通过符号链接和内容寻址存储极大优化了磁盘空间和安装速度；更严格的依赖管理避免了“幻影依赖”问题；内置对 workspace: 协议的良好支持。OA-WX 也是基于 pnpm
    - 可接受劣势: 相对于 Yarn 可能生态工具链稍少（但差距逐渐缩小），足以满足本项目需求。
2. 新 OMS 应用框架选型:
  - 对比维度: 开发体验、生态系统成熟度、内置功能（路由、构建、微前端支持）、文档完善度、社区活跃度、与公司现有技术栈/能力的契合度。
  - 方案: Umi v4 vs. yqg-max 。
  - 结论: 待定。
    - Umi: 
      - 优势:文档极其完善，社区庞大活跃，极大降低学习成本和问题解决时间；功能集丰富且经过大规模验证（插件化架构、开箱即用的 AntD 集成、内置 Qiankun 支持等）。
      - 劣势:需要额外投入精力将其与公司特定的内部系统（如认证、监控）进行集成
    - Yqg-max:
      - 优势:现成的套件,开箱即用,已经集成相关插件React PC 套件一期方案。
      - 劣势:文档不完善；微前端能力未知；技术选型可能受内部限制
3. 微前端集成方案 (用于二期: oms-next 集成旧 oms):
  - 对比维度: 隔离性（JS/CSS）、主子应用通信机制、资源加载方式、对不同版本 React 及 antd的兼容性、与主应用框架的集成度、社区成熟度。
  - 方案: Umi Qiankun Plugin vs. Yqg-max 微前端方案 vs. MF。
  - 结论:  待定。
    - Umi Qiankun Plugin
      - 优势: 成熟的沙箱机制，处理 React/AntD 版本差异相对简单直接，适合应用级集成。若选择 Umi，集成度高。
      - 劣势: 性能开销略高于 MF，细粒度共享能力弱
    - Yqg-max 微前端方案
      - 优势: (可能) 与框架和内部系统集成最好。
      - 劣势: 能力、成熟度、文档未知，可能是最大风险点。
    - MF:
      - 优势:客服中有成熟的应用经验微前端Module Federation接入指南.性能更好微前端 qiankun VS Module Federation
      - 劣势:文档阅读性差;处理跨主版本依赖共享非常复杂且易出错
3.2 方案总览
暂时无法在飞书文档外展示此内容
3.3 详细设计
1. 第一阶段: Monorepo 初始化 & OMS 拆分
  - 背景: 需要快速将优先级最高的 OMS 业务从单体中解耦出来，使其具备独立演进的能力。
  - 问题: 如何在不干扰 oa-next 其他部分（OA/KMG）的情况下，仅剥离 OMS？如何管理其依赖和差异？
  - 解决:
    - Monorepo 基础: 建立 pnpm, Turbo, 基础配置等。
    - 创建 oms 包: 创建 packages/oms。配置其 package.json (R16/A4 依赖), vite.config.ts, tsconfig.json。
    - 创建共享包: 创建 packages/shared-core (无框架依赖) 和 packages/shared-legacy-ui (R16/A4 peerDeps)。
    - 代码迁移 (重点):
      - 识别 oa-next 中所有与 OMS/ECOMS 功能直接相关的代码（组件、页面、路由、状态、API 调用等）。
      - 将这些代码物理迁移到 packages/oms/src。
      - 迁移 OMS 运行时所依赖的通用工具、类型到 shared-core。
      - 迁移 OMS 运行时所依赖的旧版共享 UI 组件/Hooks 到 shared-legacy-ui。
      - 注意: oa-next 中剩余的 OA/KMG 代码在此阶段保持不动。oms 包不应依赖 oa-next 中未被拆分到共享包的代码。
    - 配置化差异: 在 packages/oms 内部实现 .env + src/config.ts 机制，处理 OMS/ECOMS 变体差异。
    - 独立运行: 确保 pnpm --filter @oa/oms dev 能启动服务，pnpm --filter @oa/oms build 能成功构建。
  - 收益: 快速实现 OMS 业务的独立性，为后续现代化改造和 CI 提速打下基础，风险控制在 OMS 范围内。
2. 第二阶段: 新旧集成 (待定)
  - 背景: 需要为 OMS 现代化创建一个新的技术栈环境，并能平滑地承接现有功能。
  - 问题: 如何让新旧两个不同技术栈的应用协同工作？
  - 解决:
    - 创建 oms-next: 使用 pnpm create umi oms-next 在 packages 目录下初始化 Umi v4 项目 (R18/A5)。安装所需基础依赖 (如 antd@5)。
    - 配置 Qiankun 主应用 (oms-next): 在 oms-next 的 .umirc.ts 中，配置 qiankun: { master: { apps: [...] } }，注册 oms 为名为 legacyOmsApp 的子应用，指定其 entry 指向 oms 的访问地址（开发时是 //localhost:3001，部署后是实际地址）。
    - 配置 Qiankun 子应用 (oms)。
    - 路由集成: 在 oms-next 的路由配置中，将需要展示旧 OMS 功能的路径（例如 /oms/* 或 /legacy/orders/*）配置为加载 legacyOmsApp 微应用 (microApp: 'legacyOmsApp')。
    - 启动与验证: 同时启动 oms (Vite) 和 oms-next (Umi) 的开发服务器。访问 oms-next，导航到配置的子应用路由，确认旧 oms 页面被成功嵌入并可以基本操作。
  - 收益: 搭建了现代化的宿主环境，建立了新旧系统间的集成通道，用户可以在 oms-next 的壳中访问全部（旧版）功能，为第三阶段的替换做好准备。
3. 第三阶段: 新 UI 库搭建 & 应用(与第二阶段同步)
  - 背景: OMS 有新的 UI 设计，需要在 oms-next 中实现。
  - 问题: 如何在 oms-next 中替换旧内容？
  - 解决:
    - slimFit 组件
      - 根据 UI 设计稿，系统性地开发符合新设计规范的基础组件，并发布到私有 npm 。
    - 在 oms-next 中应用:
      - 替换策略: 采取按模块/页面逐步替换的方式。整体页面 - 模块(日常办公等)。
      - 开发新模块: 在 oms-next 中创建新的路由和组件，使用新组件以及 Umi 的功能（数据请求、状态管理等）重新实现该模块的业务逻辑。确保新模块能正确处理 OMS/ECOMS 变体配置（使用 oms-next 的配置机制）。
      - 替换路由: 完成新模块开发和测试后，修改 oms-next 的路由配置，将原指向 Qiankun 子应用中对应旧模块的路径，改为指向新实现的 Umi 组件。
      - 迭代: 重复此过程，逐步用新模块替换掉所有需要现代化的旧模块。
  - 收益: 实现了 UI 和交互的现代化升级，逐步将业务逻辑迁移到新的技术栈，最终完成 OMS 的现代化改造。
四、测试方案
4.1 自测用例
- 第一阶段:
  - oms 包独立构建 (build) 和运行 (dev) 成功。
  - oms 包能根据配置正确切换 OMS/ECOMS 模式并展示对应内容/行为。
  - oms 依赖的 shared-core, shared-legacy-ui 功能正常。
  - Turborepo 对 oms 的构建缓存生效。
- 第二阶段:
  - oms-next (主) 能成功启动。
  - oms (子) 能成功启动。
  - oms-next 能成功加载并嵌入 oms 的页面，无明显 JS 错误。
  - Qiankun 生命周期钩子在 oms 中被正确调用。(待定)
  - 主应用路由和嵌入的子应用路由间可以切换。
- 第三阶段:
  - slimfit 中的新组件符合设计规范并通过单元/组件测试。
  - oms-next 中使用新 UI 重写的模块功能与旧模块一致。
  - 重写后的模块在 OMS 和 ECOMS 模式下表现正确。
  - 路由替换后，访问相应路径展示的是新模块而非旧模块。
  - 检查新旧模块并存或切换时的样式兼容性（尽力而为）。

五、上线计划
- 第一阶段完成后:
  - 依赖: CI/CD 支持独立构建部署 oms 包。
  - 上线: 可以选择独立部署 oms 到测试环境供内部使用和测试。
- 第二阶段完成后:
  - 依赖: oms-next 可部署；旧 oms 保持在线部署状态作为子应用
  - 上线:部署 oms-next及oms
- 第三阶段进行中:
  - 上线: 在 oms-next 内部完成一个或多个模块的重写后，通过 oms-next 的部署更新上线。



